[{"title":"Python + Scipy + Matplotlib 实现任意一元函数拟合","path":"/posts/3950149617/","content":"前言 之前在大学组织里面参加校内举办的智能汽车竞赛，顺便用 Python 研究了下一元函数拟合。虽然没用到，但闲着没事的时候用 Tkinter 封装好了程序。本文大致介绍一些程序设计的思路，因为文件太大不适合在 GitHub 上部署，所以在最后附上了源代码。因为博主是 Python 初学者，所以无论是算法方面还是逻辑方面可能都会有可以优化的地方，有建议可以通过邮箱 z12502793@163.com 反馈。 工具介绍 Python Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言，具有良好的可移植性和可扩展性，最初被设计用于编写自动化脚本(shell)。随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发，在科学计算、人工智能、Web 开发、网络爬虫、数据分析等领域都有广泛的应用。 Numpy 和 Scipy NumPy 和 SciPy 是 Python 的两个科学计算库。NumPy 提供了数组对象，以及许多用于操作这些数组的函数；SciPy 是一个用于科学计算的 Python 库，它包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。NumPy 和 SciPy 的协同工作可以高效解决很多问题，在人工智能、数据分析等众多领域中得到了广泛应用。 Matplotlib 和 Pyplot Matplotlib 是 Python 的一个绘图库，它能提供多样化的输出格式实现数据可视化。Pyplot 是 Matplotlib 的子库，提供了和 MATLAB 类似的绘图API，是 Python 常用的绘图模块，能很方便绘制函数图像或统计图。 Tkinter Tkinter 提供了多种控件，如按钮，标签，文本框等，以及标准属性和方法，如大小，颜色，字体等，是Python的标准Tk GUI工具包的接口。 代码 没有用 Tkinter 打包的拟合原代码 123456789101112131415161718192021222324252627282930313233343536373839import matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as op# 定义拟合函数,可以任意修改，返回的函数表达式就是要表示成的函数形式def f(x, b, c): return b*x + c# 输入要拟合的x,y的值的原始数据x = np.array([600,700, 800, 900,1000,1100,1200,1300,1400])y = np.array([800,900,1000,1100,1200,1200,1300,1400,1490])#进行函数拟合,abcd为输出函数参数，para为拟合效果参数abcd, para = op.curve_fit(f, x, y)print(&quot; *********下面是输出函数参数********* &quot;)print(abcd)# print(&quot; *********下面是拟合效果参数********* &quot;)# print(para)# 后面都是用来看拟合图像效果的#这个两参数用于预测拟合图像在给的值之前和之后的发展情况predict_past = 100predict_future = 100#将拟合的函数转换成函数图像微分形式X = np.linspace(x[0]-predict_past, x[-1]+predict_future, 10000)Y = f(X, *abcd)#绘制拟合前数据点图效果和拟合后函数图像效果fig, ax = plt.subplots()ax.set_title(&quot;function fitting curve&quot;)ax.set_xlabel(&quot;right_speed&quot;)ax.set_ylabel(&quot;left_speed&quot;)ax.scatter(x, y)ax.plot(X, Y, color=&quot;r&quot;)plt.show() Tkinter 封装后的代码 使用方法 在 Python 环境下运行文件，在第一行中选择要拟合的变量数，第二行输入要拟合成的函数表达式（表达式为函数x侧的多项式，用 Python 数学表达式的方法表示，参数从 a 开始，数量要与要拟合的参数数保持对应；例如要拟合的函数为普通二次函数,应输入ax**2+bx+c）。 第三、四行输入要拟合的 x, y 变量的原始值，必须要一一对应，数量不能少于拟合参数数量，两个数字之间用逗号分隔。 第五行输入拟合效果图像中变量 x, y 多余的范围，例如如果要拟合二次函数输入的 x 的初始值为 1, 2, 3; 输入的 y 的初始值为 1, 4, 9; 如果需要查看图像x，y的范围均为1，则展示拟合曲线在 x=[0,4] 范围的二次曲线。如果不需要则都应该写成0,不写程序会报错。 第六行点击后即可执行程序，在右边会出现拟合函数图像，下面会出现很多个参数，依次是 a, b, c… 的拟合参数。 如果程序报错提示找不到 Numpy, Scipy, Tkinter, Matplotlib 等第三方库则需要在终端中输入 pip install 【需要的模块名】 下载对应模块。 其他报错可能是输入的问题，检查是否严格按照此处所写的使用方法执行。如果未能发现问题可以向邮箱 z12502793@163.com 进行反馈。博主只是一个爱好编程的大学生，如果发现其他 bug、优化方案也可以通过邮箱向博主提建议。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186import tkinter as tkfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAggimport matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as opimport sys# 定义拟合函数，每种对应一种参数数量def f1(x, a): return eval(entry1.get())def f2(x, a, b): return eval(entry1.get())def f3(x, a, b, c): return eval(entry1.get())def f4(x, a, b, c, d): return eval(entry1.get())def f5(x, a, b, c, d, e): return eval(entry1.get())def f6(x, a, b, c, d, e, f): return eval(entry1.get())def f7(x, a, b, c, d, e, f, g): return eval(entry1.get())def f8(x, a, b, c, d, e, f, g, h): return eval(entry1.get())# 按下按钮后执行def start(): # 清除画布上所有东西 for widget in frame_canva.winfo_children(): widget.destroy() # 要拟合的x,y的值的原始数据 x = eval(&quot;np.array([&quot; + entry2.get() + &quot;])&quot;) y = eval(&quot;np.array([&quot; + entry3.get() + &quot;])&quot;) #对每一种参数数量进行函数拟合,abcd为输出函数参数，para为拟合效果参数 if radio_value.get() == 1: abcd, para = op.curve_fit(f1, x, y) if radio_value.get() == 2: abcd, para = op.curve_fit(f2, x, y) if radio_value.get() == 3: abcd, para = op.curve_fit(f3, x, y) if radio_value.get() == 4: abcd, para = op.curve_fit(f4, x, y) if radio_value.get() == 5: abcd, para = op.curve_fit(f5, x, y) if radio_value.get() == 6: abcd, para = op.curve_fit(f6, x, y) if radio_value.get() == 7: abcd, para = op.curve_fit(f7, x, y) if radio_value.get() == 8: abcd, para = op.curve_fit(f8, x, y) # 将abcd打印出来替换原来的text6 text6 = tk.Label(frame_value, text=abcd) text6.grid(row=9, column=0, columnspan=2) # 后面都是用来看拟合图像效果的 #这个两参数用于预测拟合图像在给的值之前和之后的发展情况 predict_past = eval(&quot;np.array(&quot; + entry4.get() + &quot;)&quot;) predict_future = eval(&quot;np.array(&quot; + entry5.get() + &quot;)&quot;) #将拟合的函数转换成函数图像微分形式 X = np.linspace(x[0]-predict_past, x[-1]+predict_future, 10000) if radio_value.get() == 1: Y = f1(X, *abcd) if radio_value.get() == 2: Y = f2(X, *abcd) if radio_value.get() == 3: Y = f3(X, *abcd) if radio_value.get() == 4: Y = f4(X, *abcd) if radio_value.get() == 5: Y = f5(X, *abcd) if radio_value.get() == 6: Y = f6(X, *abcd) if radio_value.get() == 7: Y = f7(X, *abcd) if radio_value.get() == 8: Y = f8(X, *abcd) #绘制拟合前数据点图效果和拟合后函数图像效果# --------------------------------------------------------# 这段是画图像的，但不知道具体在干嘛，以后可以研究研究 fig = plt.figure(figsize=(4, 3),dpi=100)#图像比例 f_plot =fig.add_subplot(111)#划分区域 canvas = FigureCanvasTkAgg(fig,frame_canva) canvas.get_tk_widget().pack()#放置位置 plt.scatter(x, y) plt.plot(X, Y, color=&quot;r&quot;)# -------------------------------------------------------# 创建窗口window = tk.Tk()window.title(&quot;Fitting_curve&quot;)#定义四个框架，其中radio和value框架在frame里面，canva与frame并列frame = tk.Frame(window, width=150, height=80, borderwidth=5)frame_radio = tk.Frame(frame, width=150, height=80, borderwidth=5)frame_value = tk.Frame(frame, width=150, height=300, borderwidth=5)frame_canva = tk.Frame(window, width=150, height=400, borderwidth=5)# 定义radio框架中的内容text0 = tk.Label(frame_radio, text=&quot;参量数：&quot;)radio_value = tk.IntVar()radio1 = tk.Radiobutton(frame_radio, text=1, value=1, variable=radio_value)radio2 = tk.Radiobutton(frame_radio, text=2, value=2, variable=radio_value)radio3 = tk.Radiobutton(frame_radio, text=3, value=3, variable=radio_value)radio4 = tk.Radiobutton(frame_radio, text=4, value=4, variable=radio_value)radio5 = tk.Radiobutton(frame_radio, text=5, value=5, variable=radio_value)radio6 = tk.Radiobutton(frame_radio, text=6, value=6, variable=radio_value)radio7 = tk.Radiobutton(frame_radio, text=7, value=7, variable=radio_value)radio8 = tk.Radiobutton(frame_radio, text=8, value=8, variable=radio_value)#定义value框架中的内容text1 = tk.Label(frame_value, text=&quot;输入要拟合成的函数表达式&quot;)entry1 = tk.Entry(frame_value, width= 50)text2 = tk.Label(frame_value, text=&quot;输入要拟合的x变量&quot;)entry2 = tk.Entry(frame_value, width= 50)text3 = tk.Label(frame_value, text=&quot;输入要拟合的y变量&quot;)entry3 = tk.Entry(frame_value, width= 50)text4 = tk.Label(frame_value, text=&quot;输入要预测的x变量范围&quot;)entry4 = tk.Entry(frame_value, width= 25)text5 = tk.Label(frame_value, text=&quot;输入要预测的y变量范围&quot;)entry5 = tk.Entry(frame_value, width= 25)text6 = tk.Label(frame_value, text=&quot;&quot;)button = tk.Button(frame_value, text=&quot;开始拟合&quot;, command=start, pady=3)# 将radio和value一依次放在frame的上面frame_radio.pack(side=&quot;top&quot;)frame_value.pack(side=&quot;top&quot;)# 将radio中的东西用grid放置text0.grid(row=0, column=0)radio1.grid(row=0, column=1)radio2.grid(row=0, column=2)radio3.grid(row=0, column=3)radio4.grid(row=0, column=4)radio5.grid(row=0, column=5)radio6.grid(row=0, column=6)radio7.grid(row=0, column=7)radio8.grid(row=0, column=8)# 将value中的东西用grid放置text1.grid(row=0, column=0, columnspan=2)entry1.grid(row=1, column=0, columnspan=2,)text2.grid(row=2, column=0, columnspan=2)entry2.grid(row=3, column=0, columnspan=2)text3.grid(row=4, column=0, columnspan=2)entry3.grid(row=5, column=0, columnspan=2)text4.grid(row=6, column=0)entry4.grid(row=7, column=0)text5.grid(row=6, column=1)entry5.grid(row=7, column=1)text6.grid(row=9, column=0, columnspan=2)button.grid(row=8, column=0, columnspan=2)# 将frame和canva两个框架依次放在左边frame.pack(side=&quot;left&quot;)frame_canva.pack(side=&quot;left&quot;)# 在刚打开文件时还没有图像，这一段用来在刚打开文件时放一个图像fig = plt.figure(figsize=(4, 3),dpi=100)#图像比例f_plot =fig.add_subplot(111)#划分区域canvas = FigureCanvasTkAgg(fig,frame_canva)canvas.get_tk_widget().pack()#放置位置# 监测是否关掉窗口，关掉后结束程序window.protocol(&quot;WM_DELETE_WINDOW&quot;, lambda: sys.exit())# 主循环window.mainloop() 研究用：二元函数拟合 这个程序是博主和 ChatGPT 搞了一整天才实现的，依旧是通过 scipy.optimize 实现二次函数拟合。程序中很多地方博主依旧不明白是怎么实现的，但是因为勉强可以用所以也发到这篇文章中了。这个程序还在研发中所以可能有很多 Bug，如果发现可以修改的地方可以通过邮箱 z12502793@163.com 告诉博主。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import matplotlib.pyplot as pltimport numpy as npimport scipy.optimize as op# 定义拟合函数,可以任意修改，返回的函数表达式就是要表示成的函数形式def f(x, a, b, c, d, e): return a*x[0]**2 + b*x[0] + c*x[1]**2 + d*x[1] + e# 输入要拟合的x1, x2, y的值的原始数据, x1的格式与y横行长度相同，x2的格式与y竖行长度相同x1 = (1, 2, 3, 4, 5, 6)x2 = (1, 2, 3, 4, 5)y = np.array([[3, 10, 21, 36, 55, 78], [4, 11, 22, 37, 56, 79], [5, 12, 23, 38, 57, 80], [6, 13, 24, 39, 58, 81], [7, 14, 25, 40, 59, 82]])# x1, x2, y整理形式进行函数拟合x1, x2 = np.meshgrid(x1, x2)x = np.vstack((x1.flatten(), x2.flatten()))y = y.flatten()abc, para = op.curve_fit(f, x, y)print(&quot; *********下面是输出函数参数********* &quot;)print(*abc)# print(&quot; *********下面是拟合效果参数********* &quot;)# print(para)#后面都是用来看拟合图像效果的#这个两参数用于预测拟合图像在给的值之前和之后的发展情况x1_past = 3x1_future = 3x2_past = 3x2_future = 3# #将拟合的函数转换成函数图像微分形式X1 = np.linspace(x1[0, 0] - x1_past, x1[0, -1] + x1_future, 101) # 创建非周期性网格X2 = np.linspace(x2[0, 0] - x2_past, x2[-1, 0] + x2_future, 101) # 创建非周期性网格X = np.meshgrid(X1, X2)Y = (f(X, *abc))#绘制拟合前数据点图效果和拟合后函数图像效果ax = plt.subplot(projection=&quot;3d&quot;)ax.scatter(x[0], x[1], y, color=&quot;black&quot;)ax.plot_surface(X[0], X[1], Y, cmap=&quot;rainbow&quot;)ax.set_xlabel(&quot;x1&quot;)ax.set_ylabel(&quot;x2&quot;)ax.set_zlabel(&quot;y&quot;)plt.show() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462module top( input wire clk , input wire rst , input signal , input signal_1 , output ld1 , output [ 7:0] seg , output [ 7:0] sel , output scl , inout sda );reg [4:0]sys_status;localparam STATUS_ILED = 5&#x27;b0_0000;localparam STATUS_PAUSE = 5&#x27;b0_0001;localparam STATUS_START = 5&#x27;b0_0010;//wire definewire [7:0] rd_data ;wire rd_data_vld\t;//reg definereg [7:0] wr_data ;reg wr_req ;reg [25:0]cnt_iic;reg flag_start_iic;reg flag_end_iic;reg [4:0]status_iic;reg flag_once;reg [4:0]wr_e2prom_status;reg [4:0]rd_e2prom_status; reg [7:0]min;reg [7:0]sec;reg [7:0]dec;reg [25:0]cnt_clk;wire flag_up ;wire flag_down ;wire flag_up_1 ;wire flag_down_1 ;wire flag_clear = (sys_status == STATUS_PAUSE) &amp;&amp; flag_up_1;reg [31:0] dsp_data\t;wire [3:0]min_h = min%8&#x27;d100/8&#x27;d10;wire [3:0]min_l = min%8&#x27;d10;//wire [3:0]min_h = rd_data%8&#x27;d100/8&#x27;d10;//wire [3:0]min_l = rd_data%8&#x27;d10;wire [3:0]sec_h = sec%8&#x27;d100/8&#x27;d10;wire [3:0]sec_l = sec%8&#x27;d10;wire [3:0]dec_h = dec%8&#x27;d10;wire status = 1&#x27;b0; wire ready;reg rd_req;reg [7:0]e2prom_addr;reg ee_nrst;wire e2prom_done;reg flag_wr_e2prom;eeprom inst_eeprom(\t.clk (clk) ,\t.rst (rst &amp;&amp; ee_nrst) ,\t.wr_req (wr_req) ,\t.rd_req (rd_req) ,\t//read data from EEPROM\t.device_id () ,\t.reg_addr (e2prom_addr) ,\t.reg_addr_vld (1&#x27;b1) ,\t.wr_data (wr_data) ,\t.wr_data_vld (wr_req) ,\t.rd_data (rd_data) ,\t.rd_data_vld (rd_data_vld)\t,\t.ready (ready) ,\t.e2prom_done(e2prom_done),\t.scl (scl) ,\t.sda (sda));always @(posedge clk or negedge rst) begin if(!rst) begin sys_status &lt;= STATUS_ILED; flag_wr_e2prom &lt;= 1&#x27;b0; end else case(sys_status) STATUS_ILED: sys_status &lt;= STATUS_PAUSE; STATUS_PAUSE: if(flag_up) sys_status &lt;= STATUS_START; else begin flag_wr_e2prom &lt;= 1&#x27;b0; end STATUS_START: if(flag_up)begin sys_status &lt;= STATUS_PAUSE; flag_wr_e2prom &lt;= 1&#x27;b1; end default: sys_status &lt;= STATUS_ILED; endcaseendlocalparam IIC_IDLE = 5&#x27;b0_0000 ;localparam IIC_START = 5&#x27;b0_0001 ;localparam IIC_WAIT = 5&#x27;b0_0010 ;localparam IIC_END = 5&#x27;b0_0100 ;always @(posedge clk or negedge rst) begin if(!rst) begin status_iic &lt;= IIC_IDLE; flag_end_iic &lt;= 1&#x27;b0; cnt_iic &lt;= 26&#x27;d0; end else case(status_iic) IIC_IDLE :begin if(flag_start_iic) status_iic &lt;= IIC_START; end IIC_START :begin if(cnt_iic == 26&#x27;d25_000_0)begin cnt_iic &lt;= 26&#x27;d0; flag_end_iic &lt;= 1&#x27;b1; status_iic &lt;= IIC_END; end else begin cnt_iic &lt;= cnt_iic + 26&#x27;d1; end end IIC_END :begin status_iic &lt;= IIC_IDLE; flag_end_iic &lt;= 1&#x27;b0; end default:begin status_iic &lt;= IIC_IDLE; flag_end_iic &lt;= 1&#x27;b0; end endcaseendlocalparam IIC_RD_IDLE = 5&#x27;b0_0000;localparam IIC_RD_START = 5&#x27;b0_0001;localparam IIC_RD_WAIT = 5&#x27;b0_0010;localparam IIC_RD_END = 5&#x27;b0_0100 ;reg [25:0]cnt_rd_iic;reg [4:0]status_rd_iic;reg flag_rd_end_iic;reg flag_rd_start_iic;always @(posedge clk or negedge rst) begin if(!rst) begin status_rd_iic &lt;= IIC_IDLE; flag_rd_end_iic &lt;= 1&#x27;b0; cnt_rd_iic &lt;= 26&#x27;d0; end else case(status_rd_iic) IIC_IDLE :begin if(flag_rd_start_iic) status_rd_iic &lt;= IIC_START; end IIC_START :begin if(cnt_rd_iic == 26&#x27;d25_000_0)begin cnt_rd_iic &lt;= 26&#x27;d0; flag_rd_end_iic &lt;= 1&#x27;b1; status_rd_iic &lt;= IIC_END; end else begin cnt_rd_iic &lt;= cnt_rd_iic + 26&#x27;d1; end end IIC_END :begin status_rd_iic &lt;= IIC_IDLE; flag_rd_end_iic &lt;= 1&#x27;b0; end default:begin status_rd_iic &lt;= IIC_IDLE; flag_rd_end_iic &lt;= 1&#x27;b0; end endcaseendlocalparam WR_IDLE = 5&#x27;b0_0000 ;localparam WR_NUM1 = 5&#x27;b0_0001 ;localparam WR_NUM2 = 5&#x27;b0_0010 ;localparam WR_NUM3 = 5&#x27;b0_0100 ;localparam WR_OVER = 5&#x27;b0_1000 ;localparam WR_DONE = 5&#x27;b1_0000 ;always @(posedge clk or negedge rst) begin if(!rst) begin ee_nrst &lt;= 1&#x27;b1; flag_once &lt;= 1&#x27;b0; end else if(wr_e2prom_status == WR_OVER &amp;&amp; flag_once == 1&#x27;b0)begin ee_nrst &lt;= 1&#x27;b0; flag_once &lt;= 1&#x27;b1; end else begin ee_nrst &lt;= 1&#x27;b1; endendreg [25:0]cnt_start;always @(posedge clk or negedge rst) begin if(!rst) cnt_start &lt;= 26&#x27;d0;\telse if(cnt_start == 26&#x27;d49_000_0) cnt_start &lt;= cnt_start; else cnt_start &lt;= cnt_start + 1;end// e2prom写入状态机always @(posedge clk or negedge rst) begin if(!rst) begin wr_e2prom_status &lt;= WR_IDLE; wr_data &lt;= 8&#x27;d0; wr_req &lt;= 1&#x27;b0; flag_start_iic &lt;= 1&#x27;b0;\tend else case(wr_e2prom_status) WR_IDLE : if(flag_wr_e2prom || flag_clear)begin wr_e2prom_status &lt;= WR_NUM1; flag_start_iic &lt;= 1&#x27;b1; wr_req &lt;= 1&#x27;b1; wr_data &lt;= (flag_clear == 1&#x27;b0)?dec:8&#x27;d0; end else begin wr_req &lt;= 1&#x27;b0; end WR_NUM1 : if(flag_end_iic)begin wr_e2prom_status &lt;= WR_NUM2; flag_start_iic &lt;= 1&#x27;b1; wr_req &lt;= 1&#x27;b1; wr_data &lt;= sec; end else begin wr_req &lt;= 1&#x27;b0; flag_start_iic &lt;= 1&#x27;b0; end WR_NUM2 : if(flag_end_iic)begin wr_e2prom_status &lt;= WR_NUM3; flag_start_iic &lt;= 1&#x27;b1; wr_req &lt;= 1&#x27;b1; wr_data &lt;= min; end else begin wr_req &lt;= 1&#x27;b0; flag_start_iic &lt;= 1&#x27;b0; end WR_NUM3 : if(flag_end_iic)begin wr_e2prom_status &lt;= WR_OVER; flag_start_iic &lt;= 1&#x27;b1; wr_req &lt;= 1&#x27;b0; end else begin wr_req &lt;= 1&#x27;b0; flag_start_iic &lt;= 1&#x27;b0; end WR_OVER: if(flag_end_iic)begin wr_e2prom_status &lt;= WR_DONE; flag_start_iic &lt;= 1&#x27;b0; wr_req &lt;= 1&#x27;b0; end else begin wr_req &lt;= 1&#x27;b0; end WR_DONE: wr_e2prom_status &lt;= WR_DONE; default: wr_e2prom_status &lt;= WR_IDLE;\tendcase\tendlocalparam RD_IDLE = 5&#x27;b0_0000;localparam RD_NUM1 = 5&#x27;b0_0001;localparam RD_NUM2 = 5&#x27;b0_0010;localparam RD_NUM3 = 5&#x27;b0_0100;localparam RD_OVER = 5&#x27;b0_1000;// e2prom读取状态机always @(posedge clk or negedge rst) begin if(!rst) begin rd_e2prom_status &lt;= RD_IDLE; rd_req &lt;= 1&#x27;b0; flag_rd_start_iic &lt;= 1&#x27;b0;\tend else case(rd_e2prom_status) RD_IDLE : if(1&#x27;b1)begin rd_e2prom_status &lt;= RD_NUM1; flag_rd_start_iic &lt;= 1&#x27;b1; rd_req &lt;= 1&#x27;b1; end else begin rd_req &lt;= 1&#x27;b0; end RD_NUM1 : if(flag_rd_end_iic)begin rd_e2prom_status &lt;= RD_NUM2; flag_rd_start_iic &lt;= 1&#x27;b1; rd_req &lt;= 1&#x27;b1; end else begin rd_req &lt;= 1&#x27;b0; flag_rd_start_iic &lt;= 1&#x27;b0; end RD_NUM2 : if(flag_rd_end_iic)begin rd_e2prom_status &lt;= RD_NUM3; flag_rd_start_iic &lt;= 1&#x27;b1; rd_req &lt;= 1&#x27;b1; end else begin flag_rd_start_iic &lt;= 1&#x27;b0; rd_req &lt;= 1&#x27;b0; end RD_NUM3 : if(flag_rd_end_iic)begin rd_e2prom_status &lt;= RD_OVER; flag_rd_start_iic &lt;= 1&#x27;b0; end else begin rd_req &lt;= 1&#x27;b0; flag_rd_start_iic &lt;= 1&#x27;b0; end RD_OVER:begin rd_e2prom_status &lt;= rd_e2prom_status; rd_req &lt;= 1&#x27;b0; end default: rd_e2prom_status &lt;= RD_IDLE;\tendcaseend always@(*)begin\tif(rd_e2prom_status == RD_NUM1 || wr_e2prom_status == WR_NUM1) e2prom_addr = 8&#x27;d3;\telse if(rd_e2prom_status == RD_NUM2 || wr_e2prom_status == WR_NUM2) e2prom_addr = 8&#x27;d4;\telse if(rd_e2prom_status == RD_NUM3 || wr_e2prom_status == WR_NUM3) e2prom_addr = 8&#x27;d5;\telse e2prom_addr = 8&#x27;d0;end localparam MAX_CNT = 26&#x27;d50_000_000 - 1;always @(posedge clk or negedge rst) begin if(!rst) begin cnt_clk &lt;= 26&#x27;d0; end else if(sys_status == STATUS_START) begin if(cnt_clk == MAX_CNT) cnt_clk &lt;= 26&#x27;d0; else cnt_clk &lt;= cnt_clk + 1&#x27;b1; end else if(flag_clear) cnt_clk &lt;= 26&#x27;d0;endalways @(posedge clk or negedge rst) begin if(!rst ) begin min &lt;= 8&#x27;d0; sec &lt;= 8&#x27;d0; dec &lt;= 8&#x27;d0;\tend else if(flag_clear)begin min &lt;= 8&#x27;d0; sec &lt;= 8&#x27;d0; dec &lt;= 8&#x27;d0; end else if(sys_status == STATUS_PAUSE)begin if(rd_e2prom_status == RD_NUM1 &amp;&amp; flag_rd_end_iic) dec &lt;= rd_data; else if(rd_e2prom_status == RD_NUM2 &amp;&amp; flag_rd_end_iic) sec &lt;= rd_data; else if(rd_e2prom_status == RD_NUM3 &amp;&amp; flag_rd_end_iic) min &lt;= rd_data; end else if(sys_status == STATUS_START)begin if(cnt_clk % 26&#x27;d49_999_99 == 0 &amp;&amp; dec == 8&#x27;d9)begin dec &lt;= 8&#x27;d0; sec &lt;= sec + 1; end else if(cnt_clk % 26&#x27;d49_999_99 == 0)begin dec &lt;= dec + 8&#x27;d1; end if(cnt_clk % 26&#x27;d49_999_99 == 0 &amp;&amp; dec == 8&#x27;d9)begin//1s到了 if(sec == 8&#x27;d59)begin sec &lt;= 0; min &lt;= min + 1; end else begin sec &lt;= sec + 1; end end endendassign ld1 = (sys_status == STATUS_START)?1&#x27;b0: (sys_status == STATUS_PAUSE)?1&#x27;b1:1&#x27;b1;key_fiter u_key_fiter( .signal (signal )\t, .clk (clk )\t, .rst_n (rst )\t, .flag_up\t(flag_up ) , .flag_down (flag_down ) );key_fiter u_key_fiter_1( .signal (signal_1 )\t, .clk (clk )\t, .rst_n (rst )\t, .flag_up\t(flag_up_1 ) , .flag_down (flag_down_1 ) );always@(posedge clk or negedge rst) begin\tif (!rst) begin dsp_data &lt;= &#123;4&#x27;d10,4&#x27;d10,4&#x27;d10,4&#x27;d10,4&#x27;d10,4&#x27;d10,4&#x27;d10,4&#x27;d10&#125;;\tend else begin dsp_data &lt;= &#123;4&#x27;d14,min_h,min_l,4&#x27;d11,sec_h,sec_l,4&#x27;d11, dec_h&#125;;\tendendsegdisplay segdisplay_inst(\t.clk (clk) ,\t.rst (rst) ,\t.status (status) ,\t.seg_number_in (dsp_data) ,\t.seg_number (seg) ,\t.seg_choice (sel));endmodule","tags":["数学","Python"],"categories":["专业项目"]},{"title":"【Markdown】Markdown 语言基础语法","path":"/posts/913170794/","content":"前言 很早之前学 html 的时候就认识了 Markdown 语言，但当时对 Markdown 的理解就是 html 的简化版，所以学了也很快就忘记了。最近因为要写博客，所以顺便学习了 Markdown 的基本知识，对Markdown 文本有了更深的了解，所以写了这么一篇文章来回忆总结一下 Markdown 的基本语法和规范。 Markdown 语言介绍 Markdown是一种标记语言，排版语法非常简洁，使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。 Markdown 语言的基本语法 我认为 Markdown 就是一个更方便书写的，能够用 html 表示的一种简约的标记语言， Markdown 标记之后的文章具有比 html 更强大的可读性，而且也不需要像 Word 一样的排版和缩进，通过使用 Markdown 在不严重破坏 html 的同时增进代码中文本书写的速度。 Markdown 标题语法 Markdown 的标题是通过井号 “#” 实现的，实现方法就是多少个标题就写多少个 “#” 。井号后面要加一个空格，然后写后面的内容比如三级标题就要输入“### [内容]”。 井号越少越高级，通常一个井号代表文章标题，两个个井号代表大节，三个井号代表大节下的小标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一、二级标题可以用等号 “=” 和减号 “-” ，方法是在要输入的标题下面输入任意数量的等号或减号。 12345一级标题===二级标题--- 此外，在 Markdown 语言中，在一行中的连续三个星号“*”,破折号“-”，下划线“_”，可以实现分割线的作用。（可以在符号中间插入空格）。 123456***---___ Markdown 段落换行语法 Markdown中没有专用的换行符，创建段落就需要在两段话之间加入一个空行。 123第一行段落第二行段落 第一行段落 第二行段落 在一行的末尾加两个空格后按回车，可以实现换行。 12第一行 第二行 第一行 第二行 Markdown 强调语法 markdown 语言中使用星号 “*” 实现粗体和斜体。 要以斜体展示一段文字需要在文字两端加一对星号 “*” ，如 “*[内容]*”。 要加粗展示一段文字需要在文字两端加两对星号 “*” ，如 “**[内容]**”。 如果要对一段文字同时进行加粗和斜体展示，则需要在文字两端加三对星号“*”，如“***[内容]***”。 12345**粗体文字** *斜体文字****粗体斜体文字*** 粗体文字 斜体文字 粗体斜体文字 Markdown 引用语法 Markdown 语言通过在文字前加上小于号 “&gt;” 可以实现对一段文字进行块引用。如果需要对多段文字进行引用，怎需要在每一段文字的开头都加上小于号 “&gt;” 。 1&gt; 即使跌倒一百次，也要一百零一次地站起来。 即使跌倒一百次，也要一百零一次地站起来。 Markdown 语言还可以通过多个大于号实现多层引用（如果高层引用直接接上底层引用可能会无法正常显示）。 1234567&gt; 外层引用&gt;&gt; 中层引用&gt;&gt;&gt; 里层引用&gt;&gt;&gt;&gt; 中层引用&gt;&gt; 外层引用 Markdown 列表语法 如果 Markdown 语言中可实现类似于 html 语言的有序列表和无序列表。有序列表需要在段落前加数字和点“.”来表示，如 “1. [内容]” 。 1234561. 第一点2. 第二点3. 第三点 1. 插入第一点 2. 插入第二点4. 第四点 第一点 第二点 第三点 插入第一点 插入第二点 第四点 无序列表可以通过在段落前添加加号 “+” ，减号 “-” ，星号 “*” 中的任意一个来表示无序列表。通过灵活使用三者可以实现列表嵌套。 123456- 第一点- 第二点- 第三点 * 插入 * 插入- 第四点 第一点 第二点 第三点 插入 插入 第四点 Markdown 代码语法 在 Markdown 语言中，如果需要用段落表示代码，可以将其包裹在反引号 (`) 中。如果代码中含有单引号，可以将代码包含于两对单引号中。 1` print(&quot;hello world!&quot;) ` print(&quot;hello world!&quot;) 可以用三组反引号表示代码块，在最开始的三反引号后面写上对应的语言，在一些解释器中可以实现代码高亮表示。 123``` Pythonprint(&quot;hello world&quot;)``` 1print(&quot;hello world&quot;) Markdown 链接语法 类似于 html 中的超链接，Markdown 的超链接语法格式为 [超链接显示内容](地址 “超链接鼠标悬浮显示的标题”) 。 1[Jesse的个人博客](/) Jesse的个人博客 Markdown 图片语法 类似于 html 中的 img 标签，Markdown 的图片语法格式为 ![无法正常显示时的内容](地址 “超链接鼠标悬浮显示的标题”) ，与链接语法不同的是中括号前面要加上感叹号 “!” 。 1&#123;% image /images/covers/markdown-syntax-language.png %&#125; Markdown 转义字符语法 由于一些字符在 Markdown 语言中有具体的作用，为了在段落中能够使用这些字符，需要对字符进行转义。下面展示了所有需要在字符前加上反斜杠 “\\” 来对文字进行转义的字符。 \\\t`\t*\t_\t{}\t[]\t() # + - . ! | 1\\\\ \\` \\* \\_\t\\&#123;\\&#125;\t\\[\\]\t\\(\\)\t\\# \\+ \\- \\. \\! \\| \\\t` * _ {}\t[]\t()\t# + - . ! | 此外，由于 html 语言内部特性，，小于号“&lt;”和并号“&amp;”不能通过反斜杠 “\\”进行转义，必须要使用&amp;lt; 和 &amp;amp;对这两个字符进行转义(其他ASCII字符也可以通过这种方式进行转义)。 1&amp;amp; &amp;lt; &amp; &lt; Markdown 内嵌 HTML 标签 由于 Markdown 语言是HTML语言的简单表示形式，如果需要使用一些 HTML 中存在而 Markdown 中没有收录的 HTML 标签，或者需要通过 HTML 语言在 Markdown 文档中实现复杂的效果，如表格&lt;table&gt;标签，需要嵌入相应的 HTML 标签，直接在需要使用标签的位置嵌入即可。 123456789101112131415161718192021&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;列标题1&lt;/th&gt; &lt;th&gt;列标题2&lt;/th&gt; &lt;th&gt;列标题3&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;行1，列1&lt;/td&gt; &lt;td&gt;行1，列2&lt;/td&gt; &lt;td&gt;行1，列3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;行2，列1&lt;/td&gt; &lt;td&gt;行2，列2&lt;/td&gt; &lt;td&gt;行2，列3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 列标题1 列标题2 列标题3 行1，列1 行1，列2 行1，列3 行2，列1 行2，列2 行2，列3 如果需要在 Markdown 文档中使用注释，也可以使用 HTML 的注释格式&lt;!-- --&gt;来表示。 12345我不是注释&lt;!-- 我是注释 --&gt;我不是注释 我不是注释 我不是注释 hexo-renderer-markdown-it 介绍 hexo-renderer-markdown-it 式一个 hexo 的 Markdown 解释器，因为 Markdown 解释器众多，仅仅是在细节上有差别，所以正常使用的话用哪个都差不多，但如果需要进行数学表达式等就需要考虑解释器的问题了。博主使用 hexo-renderer-markdown-it，支持 MathJax（适配不是很好，需要调整），可以使用类似于 GFM 的所有功能，还有一些 hexo-renderer-markdown-it 独有的功能，下面对 hexo-renderer-markdown-it 的附增 Markdown 语法做一个研究和介绍。 hexo-renderer-markdown-it 语法 hexo-renderer-markdown-it 表格语法 在 hexo-renderer-markdown-it 中，可以通过连字符和“-”，通道符号“|”两个符号围成表格，来代替原本 Markdown 语言中的表格标签（GFM 语法也可以实现）。表格尺寸可以自定义，表头与表格体用对应的多个连词符分开。 1234| 列标题一 | 列标题二 | 列标题三 | | --- | --- | --- || 行1，列1 | 行1，列2 | 行1，列3 | | 行2，列1 | 行2，列2 | 行2，列3 | 列标题一 列标题二 列标题三 行1，列1 行1，列2 行1，列3 行2，列1 行2，列2 行2，列3 hexo-renderer-markdown-it 删除线语法 hexo-renderer-markdown-it 中任意两对双波浪线 “ ~~ ”,可以实现删除线的效果，即 HTML 中的 &lt;del&gt; 标签（GFM 中也可以实现）。 1~~del~~ del 注：单词两端不能加空格 ###hexo-renderer-markdown-it Emoji表情语法 hexo-renderer-markdown-it 中，可以通过在两端写上冒号 “:” 来表示 Emoji 表情（在 GFM 中也可以实现）。 1234:grinning::heart_eyes::speech_balloon::peach: 😀 😍 💬 🍑 这些表情有很多，和 HTML 标签混合可以实现很多有趣的效果。可以在github官方表情中查找对应表情的编码。 hexo-renderer-markdown-it 任务列表项语法 hexo-renderer-markdown-it 中，可以通过类似于无序列表，在加号 “+” ，连词符 “-” 或星号 “*” 后面加上空格中括号[ ]或者 “x” 中括号[x]来实现任务列表项。填写列表项后对应的 Markdown 源代码也会发生改变。（GFM 也可以实现） 1234- [ ] 待办事项1- [ ] 待办事项2- [x] 待办事项3- [ ] 待办事项4 待办事项1 待办事项2 待办事项3 待办事项4 hexo-renderer-markdown-it 上下标语法 hexo-renderer-markdown-it 通过在内容两边加上“^”表示上标，加上“~”表示下标（无法共同表示）。 1x^2^~1~+x^2^~2~ = 1 x21 + x22 = 1 hexo-renderer-markdown-it 标记下划线语法 hexo-renderer-markdown-it 通过在内容两边加上两个等号“==”表示标记，加两个加号“++”表示下划线。 12==标记==++下划线++ 标记下划线 自动链接语法 hexo-renderer-markdown-it 中，可以在文件中写域名或网站，会直接变成一个链接。 www.bing.com z12502793@163.com hexo-renderer-markdown-it 折叠 在一段文字前后加上三个加号“+++”可以实现折叠功能,折叠前的文字用前后各两个星号“*”包围。 123+++ **展开**隐藏内容+++ &nbsp;展开隐藏内容 自定义容器 可以实现自定义容器（大概为设置 div 盒子中的 id），在 hexo 或其他网站的 css 中添加即可自定义容器，使用的方法为在段落前后加上三个冒号，第一段空格加上 容器的 id 名即可实现自定义容器，下面是四个例子。 12345678910111213141516171819::: tips**提示**这是一个提示:::::: warning**注意**这是一个警告:::::: danger**警告**这是一个危险信号:::::: success**成功**这是一个成功信号::: 提示 这是一个提示 注意 这是一个警告 警告 这是一个危险信号 成功 这是一个成功信号","tags":["Markdown"],"categories":["技术小屋","Markdown"]},{"title":"小站建设日志","path":"/posts/3847924491/","content":"小站建设历史 2023-11-26 通过 Hexo 的 Chic 主题完成网站搭建，上传了第一篇文章。 2023-11-27 改用 Hexo 的 Stellar 主题，完成了博客的 about 部分。 2023-12-01 创建博客建设日志。 2023-12-03 创建分类目录，创建博客的五种分类。 2023-12-08 将网站最初的日记目录更改为 abbr 目录，防止未来出现死链；将解释器从 pandoc 改为 renderer-markdown-it。 2023-12-08 修改了网站的 css，加上了 id 为 tips, success, warning, danger 的样式，用于自定义盒子。 2023-12-12 统一 Markdown 文档的文件格式。 2024-03-15 重新启动博客。 2024-08-02 修改内容。 2025-07-08 重新启动博客，应用于本人大学本科四年的全部项目整理","tags":["小站维护"],"categories":["小站维护"]},{"title":"about","path":"/about/index.html","content":"个人介绍 欢迎来到 JesseZG 的小破站！在博客中会记录一些博主的作品、学习笔记和学习历程。 本站由 Hexo 的 stellar 制作搭建于 GitHub 上，目前是静态网站，所以没办法留言，有建议可以通过邮箱 z12502793@163.com 联系博主。（博主非常期待！） 虽然这个小站还是很穷，但博主会一点一点地让这里富裕起来的(ᕑᗢᓫ∗)˒"},{"title":"friends","path":"/friends/index.html","content":"目前没有找到朋友懂Web (っ◞‸◟c)"}]